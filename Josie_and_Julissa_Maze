/*Code for a maze of blocks the user moves through with mouse movement. The user should avoid the blocks and collect gems to earn points. Main data structure uses arrays. 

By: Josie Shirah and Julissa Tenas for URI CSC 106 Final Project on 5/11/2021*/

//Global Variables
var currentScene = 0; //Splash scene = 0, instructions = 1, game play = 2
var NUM_BLOCKS = 200; //Total number of blocks moving in each direction
var BLOCK_SIZE = 20; //heighth and width of the blocks
var NUM_GEMS = 15; //Total number of gems to be collected
var score = 0; //inital score
var stillPlaying = true; //playing game = true, false = gems all collected
var xblocks = []; //array of blocks moving across x axis
var yblocks = []; //array of blocks moving across y axis
var gems = []; //array of gems that appear sequentially throughout game


//bitmoji functions, parameters for x pos, y pos, and height
var drawBitmojiBodyJosie=function(x,y,h){
   noStroke();
    fill(25, 82, 120);//shirt color
    quad(x-(h/100*39),y+(h/100*55),x+(h/100*40),y+(h/100*55),x+(h/100*37),y+(h/100*18),x-(h/100*35),y+(h/100*18));//shirt
    fill(255, 226, 198);//Skin tone
    ellipse(x,y+(h/100*8),(h/100*29),(h/100*38));//neck shirt line
    fill(255, 255, 255); //text color
    textSize((h/100)*16);
    text("JS",x-(h/90*7),y+(h/122*45));//shirt initials
    noStroke();
    fill(176, 176, 176);//hat color
    arc(x,y-(h/100*35),(h/100*62),(h/100*55),0,360);//hat base shape
    fill(195,144,57);//hair color
    ellipse(x,y-(h/100*19),(h/100*60),(h/100*72));//part 1 hair
    fill(195,144,57);//hair color
    rect(x+(h/100*9),y-(h/100*13),(h/100*20),(h/100*50));//right bottom hair
    rect(x-(h/100*30),y-(h/100*13),(h/100*20),(h/100*50));//left bottom hair
};
var drawBitmojiHeadJosie=function(x,y,h){
    fill(255, 226, 198);//Skin tone
    noStroke();// no outline
    rect(x-(h/100*10),y-(h/100*4),(h/100*19),(h/100*22));//neck
    stroke(186, 151, 151);//face outline
    ellipse(x,y-(h/100*19),(h/100*48),(h/100*59));//face
    
    noStroke();
    fill(195,144,57);//hair color
    rect(x+(h/100*21),y-(h/100*32),(h/100*5),(h/100*39));//right hair over face
    rect(x-(h/100*26),y-(h/100*32),(h/100*5),(h/100*39));//left hair over face
    fill(176, 176, 176);//hat color
    arc(x-(h/100*20),y-(h/100*42),(h/100*18),(h/100*21),138,309);//hat help shape
    arc(x+(h/100*17),y-(h/100*46),(h/100*22),(h/100*13),244,410);//hat help shape
    
    noStroke();
    fill(255, 255, 255);//eye white
    ellipse(x+(h/100*9),y-(h/100*27),(h/100*12),(h/100*8));//right eye white
    ellipse(x-(h/100*7),y-(h/100*27),(h/100*12),(h/100*8));//right eye white
    fill (112, 94, 7);//eye color
    ellipse(x+(h/100*9),y-(h/100*27),(h/100*5),(h/100*5));//right eye
    ellipse(x-(h/100*7),y-(h/100*27),(h/100*5),(h/100*5));//left eye
    fill(255, 226, 198);//Skin tone
    strokeWeight(1);
    stroke(0, 0, 0);//nose outline
    bezier(x-(h/100*2),y-(h/100*13),x+(h/100*9),y-(h/100*13),x+(h/100*1),y-(h/100*18),x+(h/100*1),y-(h/100*24));//nose
    stroke(219, 105, 105); //mouth outline color
    line(x+(h/100*12),y-(h/100*6.5),x-(h/100*12),y-(h/100*6.5));//top lip
    fill(255,255,255);//teeth color
    arc(x,y-(h/100*6),(h/100*23),(h/100*15),0,180);//mouth
};
var drawBitmojiJosie=function(x,y,h){
    drawBitmojiBodyJosie(x,y,h);
    drawBitmojiHeadJosie(x,y,h);
    stroke(0,0,0);
};
var drawBitmojiJulissa = function(bitmojiX,bitmojiY,bitmojiHeight){
    stroke(0, 0, 0);
    strokeWeight(1);
    fill(23, 15, 15);//black
    rect(bitmojiX + (bitmojiHeight / 50) * 130, bitmojiY + (bitmojiHeight / 50) * 60, (bitmojiHeight / 50) * 99, (bitmojiHeight / 50) * 172);//hair
    
    fill(237, 195, 118);//skin color
    arc(bitmojiX + (bitmojiHeight / 50) * 180, bitmojiY + (bitmojiHeight / 50) * 139, (bitmojiHeight / 50) * 86, (bitmojiHeight / 50) * 110, 68, 111); //neck
    ellipse(bitmojiX + (bitmojiHeight / 50) * 180, bitmojiY + (bitmojiHeight / 50) * 109, (bitmojiHeight / 50) * 89, (bitmojiHeight / 50) * 128); //face
    fill(23, 15, 15);//skin color
    arc(bitmojiX + (bitmojiHeight / 50) * 180, bitmojiY + (bitmojiHeight / 50) * 61, (bitmojiHeight / 50) * 99,(bitmojiHeight / 50) * -44, -31, 211); //scalp
    arc(bitmojiX + (bitmojiHeight / 50) * 136, bitmojiY + (bitmojiHeight / 50) * 119, (bitmojiHeight / 50)* 23, (bitmojiHeight / 50) * 136, 131, 307); //left side inner hair
    arc(bitmojiX + (bitmojiHeight / 50) * 222, bitmojiY + (bitmojiHeight/50) * 120, (bitmojiHeight/50) * 28, (bitmojiHeight / 50) * 136, -131, 45); //right side inner hair
    arc(bitmojiX + (bitmojiHeight / 50) * 132, bitmojiY + (bitmojiHeight / 50) * 124, (bitmojiHeight / 50 ) * 23, (bitmojiHeight / 50) * 136, 131, 307); //left middle inner hair
    arc(bitmojiX + (bitmojiHeight / 50) * 227, bitmojiY + (bitmojiHeight / 50) * 121, (bitmojiHeight / 50) * 20, (bitmojiHeight / 50) * 127, -103, 66); //right middle inner hair
    arc(bitmojiX + (bitmojiHeight / 50) * 131, bitmojiY + (bitmojiHeight / 50) * 157, (bitmojiHeight / 50) * 23, (bitmojiHeight / 50) * 138, 41, 308); //left side outer hair
    arc(bitmojiX + (bitmojiHeight / 50) * 224, bitmojiY + (bitmojiHeight / 50) * 161, (bitmojiHeight / 50) * 28, (bitmojiHeight / 50) * 135, -113, 145); //right side outer hair
    arc(bitmojiX + (bitmojiHeight / 50) * 141, bitmojiY + (bitmojiHeight / 50) * 145, (bitmojiHeight / 50) * 29, (bitmojiHeight / 50) * 110, 18, 259); //right jaw 
    arc(bitmojiX + (bitmojiHeight / 50) * 225, bitmojiY + (bitmojiHeight / 50) * 149, (bitmojiHeight / 50) * 27, (bitmojiHeight / 50) * 109, -78, 165); //left jaw 
    
    fill(237, 195, 118);//smile
    arc(bitmojiX + (bitmojiHeight / 50) *181, bitmojiY + (bitmojiHeight/50) * 145, (bitmojiHeight / 50) * 29, (bitmojiHeight / 50) * 18, 376, 517);//mouth
    
    noStroke();
    fill(232, 126, 147);//pink
    arc(bitmojiX + (bitmojiHeight / 50) * 181, bitmojiY + (bitmojiHeight / 50) * 147, (bitmojiHeight / 50) * 25, (bitmojiHeight / 50) * 20, 384, 517); //lips
    
    fill(15, 15, 15);//black
    arc(bitmojiX + (bitmojiHeight / 50) * 198, bitmojiY + (bitmojiHeight / 50) * 87, (bitmojiHeight / 50) * 24, (bitmojiHeight / 50) * 6, 171, 383); //right eyebrow
    arc(bitmojiX + (bitmojiHeight / 50) * 158, bitmojiY + (bitmojiHeight / 50) * 87, (bitmojiHeight / 50) * 24, (bitmojiHeight / 50) * 6, 154, 369);//left eyebrow
    
    stroke(0, 0, 0);
    strokeWeight(1);
    fill(255, 255, 255);//white
    arc(bitmojiX + (bitmojiHeight / 50) * 199, bitmojiY + (bitmojiHeight / 50) * 106, (bitmojiHeight / 50) * 29, (bitmojiHeight / 50) * 27, 171, 372);//right cornea
    arc(bitmojiX + (bitmojiHeight / 50) * 160, bitmojiY + (bitmojiHeight / 50) * 106, (bitmojiHeight / 50) * 29, (bitmojiHeight / 50) * 27, 171, 372);//left cornea
    
    fill(130, 103, 5);//brown
    ellipse(bitmojiX + (bitmojiHeight / 50) * 199, bitmojiY + (bitmojiHeight / 50) * 106, (bitmojiHeight / 50) * 10, (bitmojiHeight / 50) * 10);//right eye
    ellipse(bitmojiX + (bitmojiHeight  /50) * 160, bitmojiY + (bitmojiHeight / 50) * 106, (bitmojiHeight / 50) * 10, (bitmojiHeight / 50) * 10);//left eye
    
    stroke(0, 0, 0);
    strokeWeight(1);
    fill(237, 195, 118);//skin color
    ellipse(bitmojiX + (bitmojiHeight / 50) * 180, bitmojiY + (bitmojiHeight / 50) * 129, (bitmojiHeight / 50) * 10, (bitmojiHeight / 50) *10);//nose
    ellipse(bitmojiX + (bitmojiHeight / 50) * 175, bitmojiY + (bitmojiHeight / 50) * 127, (bitmojiHeight / 50) * 10, (bitmojiHeight / 50) * 10);//nose
    ellipse(bitmojiX + (bitmojiHeight / 50) * 185, bitmojiY + (bitmojiHeight / 50) * 127, (bitmojiHeight / 50) * 10, (bitmojiHeight / 50) * 10);//nose
    
    stroke(0, 0, 0);
    strokeWeight(1);
    fill(240, 40, 64);
    arc(bitmojiX + (bitmojiHeight / 50) * 180,bitmojiY + (bitmojiHeight / 50) * 65, (bitmojiHeight / 50) * 119, (bitmojiHeight / 50) * 66, 161, 381);//hat
    ellipse(bitmojiX + (bitmojiHeight / 50) * 180, bitmojiY + (bitmojiHeight / 50)*67, (bitmojiHeight / 50) * 93, (bitmojiHeight / 50) * 11); //hatlid
    stroke(237, 195, 118);
    strokeWeight(1);
    fill(237, 195, 118);
    ellipse(bitmojiX  + (bitmojiHeight / 50) * 180, bitmojiY + (bitmojiHeight / 50) * 128, (bitmojiHeight / 50) * 10, (bitmojiHeight / 50) * 10);//nose
    ellipse(bitmojiX + (bitmojiHeight / 50) * 180, bitmojiY + (bitmojiHeight / 50) * 123, (bitmojiHeight / 50) * 10, (bitmojiHeight / 50) * 10);//nose
    noStroke();
    fill(237, 195, 118);//skin color
    rect(bitmojiX + (bitmojiHeight / 50) * 138, bitmojiY + (bitmojiHeight / 50) * 224, (bitmojiHeight / 50) * 14, (bitmojiHeight / 50) * 60);//left arm
    rect(bitmojiX + (bitmojiHeight / 50) * 212, bitmojiY + (bitmojiHeight / 50) * 227, (bitmojiHeight / 50) * 14, (bitmojiHeight / 50) * 60, (bitmojiHeight / 50) * 107);// right arm
    arc(bitmojiX + (bitmojiHeight / 50) * 214, bitmojiY + (bitmojiHeight / 50) * 293, (bitmojiHeight / 50) * 29, (bitmojiHeight / 50) * 27, 286, 436);//right hand
    arc(bitmojiX + (bitmojiHeight / 50) * 151, bitmojiY + (bitmojiHeight / 50) * 292, (bitmojiHeight / 50) * 29, (bitmojiHeight / 50) * 27, 464, 615);//left hand
    stroke(18, 26, 69); 
    strokeWeight(1);
    fill(18, 26, 69);
    rect(bitmojiX + (bitmojiHeight / 50) * 194, bitmojiY + (bitmojiHeight / 50) * 191, ( bitmojiHeight / 50) * 37, (bitmojiHeight / 50) * 46, (bitmojiHeight / 50) * 107);//shirt sleeve right
    rect(bitmojiX + (bitmojiHeight / 50) * 136, bitmojiY + (bitmojiHeight / 50) * 191, (bitmojiHeight / 50) * 37, (bitmojiHeight / 50) * 46, (bitmojiHeight / 50)  * 107);//shirt sleeve left
    rect(bitmojiX + (bitmojiHeight / 50) * 150, bitmojiY + (bitmojiHeight / 50) * 187, (bitmojiHeight / 50) * 64, (bitmojiHeight / 50) * 99, (bitmojiHeight / 50) * 14);//shirt base
stroke(255, 255, 255);
strokeWeight(2);
fill(18, 26, 69);
line(bitmojiX + (bitmojiHeight / 50) * 157, bitmojiY + (bitmojiHeight / 50) * 211, bitmojiX + (bitmojiHeight / 50) * 178,bitmojiY + (bitmojiHeight / 50) * 211);//horizontal j
    line(bitmojiX + (bitmojiHeight / 50) * 169, bitmojiY + (bitmojiHeight / 50) * 234, bitmojiX + (bitmojiHeight / 50) * 168, bitmojiY + (bitmojiHeight / 50) * 212);//veritcal j
    line(bitmojiX + (bitmojiHeight / 50) * 158, bitmojiY + (bitmojiHeight / 50) * 235, bitmojiX + (bitmojiHeight / 50) * 167, bitmojiY + (bitmojiHeight / 50) * 235);// j loop
    line(bitmojiX + (bitmojiHeight / 50) * 196, bitmojiY + (bitmojiHeight / 50) * 234, bitmojiX + (bitmojiHeight / 50) * 195, bitmojiY + (bitmojiHeight / 50) * 214);// horizontal t
    line(bitmojiX + (bitmojiHeight / 50) * 187, bitmojiY + (bitmojiHeight / 50) * 212, bitmojiX + (bitmojiHeight / 50) * 206, bitmojiY + (bitmojiHeight / 50) * 211);//horizontal t
    stroke(0, 0, 0);
};

        /*Objects and their functions are defined below*/

    /*Button object class, creates buttons for user interaction*/
//constructor function for class button
var Button = function(config) {
    this.x = config.x || 0;
    this.y = config.y || 0;
    this.width = config.width || 150;
    this.height = config.height || 50;
    this.label = config.label || "Click";
    this.onClick = config.onClick || function() {};
    this.buttonColor = config.buttonColor ||color(0, 255, 55);
    //this.bitmojis = config.bitmojis || function(){};
}; 

//draws rectangle for class Button below
Button.prototype.draw = function() {
    fill(this.buttonColor);
    rect(this.x, this.y, this.width, this.height, 5);
    fill(0, 0, 0);
    textSize(19);
    textAlign(LEFT, TOP);
    text(this.label, this.x+7, this.y+this.height/4);
    //this.bitmojis
}; 

//prototype below checks if mouse is inside the button
Button.prototype.isMouseInside = function() {
    return mouseX > this.x &&
           mouseX < (this.x + this.width) &&
           mouseY > this.y &&
           mouseY < (this.y + this.height);
};

//prototype below checks if mouse is inside then runs onclick function 
Button.prototype.handleMouseClick = function() {
    if (this.isMouseInside()) {
        this.onClick();
    }
}; 


    /*Bitmoji object class, creates user icon*/
/*constructor function for class Bitmoji below, parameters: x pos, y pos, height, and character (either josie or julissa*/
var Bitmoji = function(x, y, height, character){
    this.x = x;
    this.y = y;
    this.height = height;
    this.bitmojiImg = character;
    this.blocksHit = 0;
    this.gemsCollected = 0;
};

//function below for class Bitmoji, calls the bitmoji functions at location of mouse
Bitmoji.prototype.draw = function(){
    this.x = mouseX;
    this.y = mouseY;
    this.bitmojiImg(this.x, this.y, this.height);
};

/*function below for class Bitmoji checks if object is over block and subtracts points, parameter: b is either block array of specified index*/
Bitmoji.prototype.hitByBlock = function(b) {
    if (b.x >= (this.x-20) && b.x <= (this.x + 20) && b.y >= (this.y-20) && b.y <= (this.y + 40) && b.blockColor=== color(255,0,0))
    {
        this.blocksHit++; //REMOVE THIS??
        score -=  5;
        b.blockColor=color(0, 106, 255);
    }    
};

/*function below for class Bitmoji checks if object is over gem and adds points, parameter: g is the gem array of a specified index*/ 
Bitmoji.prototype.collectGem = function(g) {
    if ((g.x >= (this.x-50) && g.x <= (this.x + 50)) && (g.y >= (this.y-50) && g.y <= (this.y + 50)))
    {
        g.y = -400;
        this.gemsCollected++;
        score +=  30;
    }
};


    /*Block object class, user must avoid objects of this class*/
//constructor function for class Block below, parameters: x pos, y pos, side length
var Block = function(x, y, blockLength) { 
    this.x = x;
    this.y = y;
    this.height = blockLength;
    this.width = blockLength;
    this.speed = 1.5;
    this.blockColor = color(255, 0, 0);
};

//function below describes how to draw the objects of class Block
Block.prototype.draw = function() {
    fill(this.blockColor);
    rect(this.x, this.y, this.height, this.width);
};


    /*Gem object class, user must collect objects of class Gem*/
//constructor function for class Gem below, parameters: x pos, y pos
var Gem = function(x,y){
    this.x=x;
    this.y=y;
    this.img=getImage("cute/GemGreen");
};

//function below calls an image of the specified image at the objects location 
Gem.prototype.draw= function() {
    image(this.img, this.x, this.y, 40, 60);
};

    /*New instances of the objects are defined below*/

/*gameSetUp function resets key features and creates new instances of the objects block and gem - called in the playButton.onclick*/
var gameSetUp = function(){
    //sets arrays of moving objects to empty sets, used for play again
    xblocks = [];
    yblocks = [];
    gems = [];
    score = 0;
    stillPlaying = true;
    
    //new instances of class Block, ojects to avoid in game, stored in an array
    for (var i = 0; i < NUM_BLOCKS; i++){
        xblocks.push(new Block(11 + -i * 110 , random(10, 390), BLOCK_SIZE));
        yblocks.push(new Block(random(10,390), 11 + -i*110, BLOCK_SIZE));
    }
    //new instances of class Gem, objects to collect in game, stored in an array
    for(var k = 0; k<NUM_GEMS; k++){
        gems.push(new Gem(random(10,350),random(10,350)));
        
    }
};

//new instances of class Bitmoji, character used in game  
var julissa = new Bitmoji(200, 317, 15, drawBitmojiJulissa);
var josie = new Bitmoji(200, 200, 50, drawBitmojiJosie);

//new instances of class Button
var instructionButton = new Button({
    x: 149,
    y: 267,
    width:108,
    label: "Instructions",
    //bitmojis: drawBitmojiJosie(203,150,50),
    onClick: function() {
        currentScene=1;
    }
}); //on splash scene, sets currentScene= 1
var playButton = new Button({ 
        x: 211,
        y: 344,
        buttonColor: color(255, 10, 96),
        label: "Play!",
        textPos: 55,
        onClick: function(){
            currentScene = 2;
            gameSetUp();
        }
    }); 
    /*play button is on instruction scene, sets currentScene = 2, onclick calls gameSetUp to initialize arrays*/
var playAgainButton = new Button({ 
    x: 121,
    y: 239,
    textPos: 35,
    label: "Play Again!",
    onClick: function(){
        currentScene = 0;
        josie.gemsCollected = 0;
    }
}); //on gameEnd scene, sets currentScene =0


/*Scene functions*/
var splash = function(){
    background(144, 232, 219);
    fill(0, 0, 0);
    textSize(24);
    text("Josie and Julissa's Maze",80,210);
    instructionButton.draw();
    drawBitmojiJosie(154,153,60);
    drawBitmojiJulissa(213,106,14);
}; //splash scene, called when currentScene = 0 
var instructionsScene = function() {
    background(246,231,222,255);
    textSize(25);
    strokeWeight(10);
    fill(62, 59, 227);
    text("Blocks will move across the screen left to right and top to bottom. Use the mouse to move the avatar around avoiding the red blocks. You lose 5 points each time a block hits your avatar. Collect the green gems to gain 30 points. Watch out the speed increases when gems are collected. Game ends when all gems are collected.", 10, 10,392,580); 
    text("",94,10);
    strokeWeight(2);
    playButton.draw();
}; //instruction scene, current scene = 1
var gameEnd = function(){
    background(0, 0, 0);
    fill(0, 255, 55);
    textSize(40);
    text("Game Over", 100,150);
    textSize(30);
    text("Score: " + score , 140, 200);
    playAgainButton.draw();
    
}; //game end scene, called when gems are collected
var game = function() {
    currentScene = 2;
    background(0, 0, 0);
    fill(255, 255, 255);
    var totalCollectedGems = josie.gemsCollected;
    
    if(gems.length-1>=josie.gemsCollected){
        gems[josie.gemsCollected].draw();
        josie.collectGem(gems[josie.gemsCollected]);
    }
    else{
        currentScene = 3;
        stillPlaying = false;
    }
    for (var i = 0; i < NUM_BLOCKS; i++) {
        xblocks[i].draw();
        yblocks[i].draw();
        josie.hitByBlock(xblocks[i]);
        josie.hitByBlock(yblocks[i]);
        xblocks[i].x += xblocks[i].speed;
        yblocks[i].y += yblocks[i].speed;
        
        if(josie.gemsCollected>totalCollectedGems){
           xblocks[i].speed+=1;
           yblocks[i].speed+=1;
        }
    }
    fill(0, 255, 55);
    textSize(18);
    text("Score: " + score , 8, 24);
    josie.draw(); 
}; //game scene, called when currentScene = 2


/*predefined functions below, mouse clicked is called when the mouse is clicked, draw is repeately calls scene functions*/

mouseClicked = function(){
  if (currentScene === 0)
  {
      instructionButton.handleMouseClick();
  }
  else if (currentScene === 1)
  {
      playButton.handleMouseClick();
  }
  else if (currentScene === 3)
  {
      playAgainButton.handleMouseClick();
  } 
  

};//mouse clicked calls button onClick functions

draw = function() {
    if (currentScene === 0)
    {
        splash();
    }
    else if (currentScene === 1)
    {
        instructionsScene();
    }
    else if (currentScene === 2)
    {
        game();
    }
    else if (currentScene === 3)
    {
        gameEnd();
    }
}; //draws scenes if currentScene is at specified number
