var BitmojiHead = function(bitmojiX,bitmojiY,bitmojiHeight)// A function for the bitmoji head.
{
    stroke(0, 0, 0);
    strokeWeight(1);
    fill(23, 15, 15);//black
    rect(bitmojiX + (bitmojiHeight / 50) * 130, bitmojiY + (bitmojiHeight / 50) * 60, (bitmojiHeight / 50) * 99, (bitmojiHeight / 50) * 172);//hair
    
    fill(237, 195, 118);//skin color
    arc(bitmojiX + (bitmojiHeight / 50) * 180, bitmojiY + (bitmojiHeight / 50) * 139, (bitmojiHeight / 50) * 86, (bitmojiHeight / 50) * 110, 68, 111); //neck
    ellipse(bitmojiX + (bitmojiHeight / 50) * 180, bitmojiY + (bitmojiHeight / 50) * 109, (bitmojiHeight / 50) * 89, (bitmojiHeight / 50) * 128); //face
    fill(23, 15, 15);//skin color
    arc(bitmojiX + (bitmojiHeight / 50) * 180, bitmojiY + (bitmojiHeight / 50) * 61, (bitmojiHeight / 50) * 99,(bitmojiHeight / 50) * -44, -31, 211); //scalp
    arc(bitmojiX + (bitmojiHeight / 50) * 136, bitmojiY + (bitmojiHeight / 50) * 119, (bitmojiHeight / 50)* 23, (bitmojiHeight / 50) * 136, 131, 307); //left side inner hair
    arc(bitmojiX + (bitmojiHeight / 50) * 222, bitmojiY + (bitmojiHeight/50) * 120, (bitmojiHeight/50) * 28, (bitmojiHeight / 50) * 136, -131, 45); //right side inner hair
    arc(bitmojiX + (bitmojiHeight / 50) * 132, bitmojiY + (bitmojiHeight / 50) * 124, (bitmojiHeight / 50 ) * 23, (bitmojiHeight / 50) * 136, 131, 307); //left middle inner hair
    arc(bitmojiX + (bitmojiHeight / 50) * 227, bitmojiY + (bitmojiHeight / 50) * 121, (bitmojiHeight / 50) * 20, (bitmojiHeight / 50) * 127, -103, 66); //right middle inner hair
    arc(bitmojiX + (bitmojiHeight / 50) * 131, bitmojiY + (bitmojiHeight / 50) * 157, (bitmojiHeight / 50) * 23, (bitmojiHeight / 50) * 138, 41, 308); //left side outer hair
    arc(bitmojiX + (bitmojiHeight / 50) * 224, bitmojiY + (bitmojiHeight / 50) * 161, (bitmojiHeight / 50) * 28, (bitmojiHeight / 50) * 135, -113, 145); //right side outer hair
    arc(bitmojiX + (bitmojiHeight / 50) * 141, bitmojiY + (bitmojiHeight / 50) * 145, (bitmojiHeight / 50) * 29, (bitmojiHeight / 50) * 110, 18, 259); //right jaw 
    arc(bitmojiX + (bitmojiHeight / 50) * 225, bitmojiY + (bitmojiHeight / 50) * 149, (bitmojiHeight / 50) * 27, (bitmojiHeight / 50) * 109, -78, 165); //left jaw 
    
    fill(237, 195, 118);//smile
    arc(bitmojiX + (bitmojiHeight / 50) *181, bitmojiY + (bitmojiHeight/50) * 145, (bitmojiHeight / 50) * 29, (bitmojiHeight / 50) * 18, 376, 517);//mouth
    
    noStroke();
    fill(232, 126, 147);//pink
    arc(bitmojiX + (bitmojiHeight / 50) * 181, bitmojiY + (bitmojiHeight / 50) * 147, (bitmojiHeight / 50) * 25, (bitmojiHeight / 50) * 20, 384, 517); //lips
    
    fill(15, 15, 15);//black
    arc(bitmojiX + (bitmojiHeight / 50) * 198, bitmojiY + (bitmojiHeight / 50) * 87, (bitmojiHeight / 50) * 24, (bitmojiHeight / 50) * 6, 171, 383); //right eyebrow
    arc(bitmojiX + (bitmojiHeight / 50) * 158, bitmojiY + (bitmojiHeight / 50) * 87, (bitmojiHeight / 50) * 24, (bitmojiHeight / 50) * 6, 154, 369);//left eyebrow
    
    stroke(0, 0, 0);
    strokeWeight(1);
    fill(255, 255, 255);//white
    arc(bitmojiX + (bitmojiHeight / 50) * 199, bitmojiY + (bitmojiHeight / 50) * 106, (bitmojiHeight / 50) * 29, (bitmojiHeight / 50) * 27, 171, 372);//right cornea
    arc(bitmojiX + (bitmojiHeight / 50) * 160, bitmojiY + (bitmojiHeight / 50) * 106, (bitmojiHeight / 50) * 29, (bitmojiHeight / 50) * 27, 171, 372);//left cornea
    
    fill(130, 103, 5);//brown
    ellipse(bitmojiX + (bitmojiHeight / 50) * 199, bitmojiY + (bitmojiHeight / 50) * 106, (bitmojiHeight / 50) * 10, (bitmojiHeight / 50) * 10);//right eye
    ellipse(bitmojiX + (bitmojiHeight  /50) * 160, bitmojiY + (bitmojiHeight / 50) * 106, (bitmojiHeight / 50) * 10, (bitmojiHeight / 50) * 10);//left eye
    
    stroke(0, 0, 0);
    strokeWeight(1);
    fill(237, 195, 118);//skin color
    ellipse(bitmojiX + (bitmojiHeight / 50) * 180, bitmojiY + (bitmojiHeight / 50) * 129, (bitmojiHeight / 50) * 10, (bitmojiHeight / 50) *10);//nose
    ellipse(bitmojiX + (bitmojiHeight / 50) * 175, bitmojiY + (bitmojiHeight / 50) * 127, (bitmojiHeight / 50) * 10, (bitmojiHeight / 50) * 10);//nose
    ellipse(bitmojiX + (bitmojiHeight / 50) * 185, bitmojiY + (bitmojiHeight / 50) * 127, (bitmojiHeight / 50) * 10, (bitmojiHeight / 50) * 10);//nose
    
    stroke(0, 0, 0);
    strokeWeight(1);
    fill(240, 40, 64);
    arc(bitmojiX + (bitmojiHeight / 50) * 180,bitmojiY + (bitmojiHeight / 50) * 65, (bitmojiHeight / 50) * 119, (bitmojiHeight / 50) * 66, 161, 381);//hat
    ellipse(bitmojiX + (bitmojiHeight / 50) * 180, bitmojiY + (bitmojiHeight / 50)*67, (bitmojiHeight / 50) * 93, (bitmojiHeight / 50) * 11); //hatlid
    stroke(237, 195, 118);
    strokeWeight(1);
    fill(237, 195, 118);
    ellipse(bitmojiX  + (bitmojiHeight / 50) * 180, bitmojiY + (bitmojiHeight / 50) * 128, (bitmojiHeight / 50) * 10, (bitmojiHeight / 50) * 10);//nose
    ellipse(bitmojiX + (bitmojiHeight / 50) * 180, bitmojiY + (bitmojiHeight / 50) * 123, (bitmojiHeight / 50) * 10, (bitmojiHeight / 50) * 10);//nose
};

var BitmojiBody = function(bitmojiX,bitmojiY,bitmojiHeight)// A function that draws the bitmoji body.
{
    noStroke();
    fill(237, 195, 118);//skin color
    rect(bitmojiX + (bitmojiHeight / 50) * 138, bitmojiY + (bitmojiHeight / 50) * 224, (bitmojiHeight / 50) * 14, (bitmojiHeight / 50) * 60);//left arm
    rect(bitmojiX + (bitmojiHeight / 50) * 212, bitmojiY + (bitmojiHeight / 50) * 227, (bitmojiHeight / 50) * 14, (bitmojiHeight / 50) * 60, (bitmojiHeight / 50) * 107);// right arm
    arc(bitmojiX + (bitmojiHeight / 50) * 214, bitmojiY + (bitmojiHeight / 50) * 293, (bitmojiHeight / 50) * 29, (bitmojiHeight / 50) * 27, 286, 436);//right hand
    arc(bitmojiX + (bitmojiHeight / 50) * 151, bitmojiY + (bitmojiHeight / 50) * 292, (bitmojiHeight / 50) * 29, (bitmojiHeight / 50) * 27, 464, 615);//left hand
    stroke(18, 26, 69); 
    strokeWeight(1);
    fill(18, 26, 69);
    rect(bitmojiX + (bitmojiHeight / 50) * 194, bitmojiY + (bitmojiHeight / 50) * 191, ( bitmojiHeight / 50) * 37, (bitmojiHeight / 50) * 46, (bitmojiHeight / 50) * 107);//shirt sleeve right
    rect(bitmojiX + (bitmojiHeight / 50) * 136, bitmojiY + (bitmojiHeight / 50) * 191, (bitmojiHeight / 50) * 37, (bitmojiHeight / 50) * 46, (bitmojiHeight / 50)  * 107);//shirt sleeve left
    rect(bitmojiX + (bitmojiHeight / 50) * 150, bitmojiY + (bitmojiHeight / 50) * 187, (bitmojiHeight / 50) * 64, (bitmojiHeight / 50) * 99, (bitmojiHeight / 50) * 14);//shirt base
    
    
    stroke(255, 255, 255);
    strokeWeight(2);
    fill(18, 26, 69);
    line(bitmojiX + (bitmojiHeight / 50) * 157, bitmojiY + (bitmojiHeight / 50) * 211, bitmojiX + (bitmojiHeight / 50) * 178,bitmojiY + (bitmojiHeight / 50) * 211);//horizontal j
    line(bitmojiX + (bitmojiHeight / 50) * 169, bitmojiY + (bitmojiHeight / 50) * 234, bitmojiX + (bitmojiHeight / 50) * 168, bitmojiY + (bitmojiHeight / 50) * 212);//veritcal j
    line(bitmojiX + (bitmojiHeight / 50) * 158, bitmojiY + (bitmojiHeight / 50) * 235, bitmojiX + (bitmojiHeight / 50) * 167, bitmojiY + (bitmojiHeight / 50) * 235);// j loop
    line(bitmojiX + (bitmojiHeight / 50) * 196, bitmojiY + (bitmojiHeight / 50) * 234, bitmojiX + (bitmojiHeight / 50) * 195, bitmojiY + (bitmojiHeight / 50) * 214);// horizontal t
    line(bitmojiX + (bitmojiHeight / 50) * 187, bitmojiY + (bitmojiHeight / 50) * 212, bitmojiX + (bitmojiHeight / 50) * 206, bitmojiY + (bitmojiHeight / 50) * 211);//horizontal t
};

var bitmojiWhole = function(bitmojiX,bitmojiY,bitmojiHeight)// A function that draws the bitmoji.
{
    BitmojiHead(bitmojiX, bitmojiY, bitmojiHeight);
    BitmojiBody(bitmojiX, bitmojiY, bitmojiHeight);
};

//data structure: array of sticks
var currentScene = 0;//Current scene at O is the Splash scene.
var numBlocks = 5;//Total number of ships.
var score = 0;//Initial score of 0.
var direction = 0; // 0 = try to get to the top, 1 = move to the down
var Button = function(btn) { // Class called "Button" with a constuctor function containing the button properties.
    this.x = btn.x || 0;
    this.y = btn.y || 0;
    this.width = btn.width || 158;
    this.height = btn.height || 46;
    this.label = btn.label || "Click";
    this.onClick = btn.onClick || function() {};
    this.color = btn.color || color(121, 121, 125);
    this.colorText = btn.colorText || color(0, 0, 0);
    this.radius = btn.radius || 25;
    this.textPos = btn.textPos || 51;
};

Button.prototype.draw = function() {//Button draw method, decorates the button.
    fill(this.color);
    rect(this.x, this.y, this.width, this.height, this.radius);
    fill(this.colorText);
    textSize(19);
    textAlign(LEFT, TOP);
    text(this.label, this.x + this.textPos, this.y + this.height / 4);
};//this is a button draw method


Button.prototype.isMouseInside = function() {//The button class, testing the isMouseInside method.
    return (mouseX > this.x &&
       mouseX < this.x + this.width &&
       mouseY > this.y &&
       mouseY < this.y + this.height);
};

Button.prototype.handleMouseClick = function() {//The button class, testing the handleMouseClick method.
    if (this.isMouseInside()) {
        this.onClick();
    }
};
var startButton = new Button(//a button instance called start button, when clicked, the Intructions Scene appears on screen.
    { 
        x: 211,
        y: 310,
        color: color(255, 10, 96),
        label: "Start!",
        onClick: function()
        {
        currentScene = 1;
        }
    });
var playButton = new Button(//a button instance called play button, when clicked, the Game Scene appears on screen.
    { 
        x: 211,
        y: 344,
        color: color(255, 10, 96),
        label: "Play!",
        textPos: 55,
        onClick: function()
        {
        currentScene = 2;
        }
    });
var playAgainButton = new Button(///a button instance called play again button, when clicked, splash Scene appears on screen.
    { 
        x: 211,
        y: 350,
        color: color(255, 10, 96),
        textPos: 35,
        label: "Play Again!",
        onClick: function()
        {
            currentScene = 0;
            loop();
            
        }
    });
var splash = function()//creates the splash scene
{
    background(246,231,222,255);
    textSize(34);
    fill(255, 10, 96);
    strokeWeight(10);
    textFont(createFont("Berlin Sans FB"), 30);
    textAlign(CENTER, TOP);
    text("Maze",185, 100);
    textSize(15);
    text("creator: Julissa & ...",86, 374);
    strokeWeight(2);
    startButton.draw();
   };
var instructionsScene = function() {//creates the instruction scene
    background(246,231,222,255);
    textSize(5);
    strokeWeight(10);
    textFont(createFont("Berlin Sans FB"), 30);
    fill(62, 59, 227);
    text("", 10, 10,392,580); 
    text("",94,10);
    strokeWeight(2);
    playButton.draw();
};

mouseClicked = function(){//This is a mouseClicked function allowing my buttons to be clickable and have its own function.
  if (currentScene === 0)
  {
      startButton.handleMouseClick();
        
  }
  else if (currentScene === 1)
  {
      playButton.handleMouseClick();
      
  }
  else if (currentScene === 2)
  {
      playAgainButton.handleMouseClick();
      
  }
};
    
var stillPlaying = true;//stillPlaying is global variable that is called  and implented in the code if the user is still playing 

var Bitmoji = function(x, y)//Object called bitmoji; creates my bitmoji
    {
        this.x = x;
        this.y = y;
        this.bitmojiImg = bitmojiWhole;
        this.ranIntoBlock = 0;
    };

Bitmoji.prototype.draw = function() {//draw method:draws itself// scoring occurs is this.y > 350 && this.y <50 ex: var direction=0 for y is 350 and direction =1 this.y is 50 (get from bottom to top = 10 points)
    fill(255, 0, 0);
    this.x = 150;
    this.y = constrain(this.y, 0,height-50);
    bitmojiWhole(this.x, this.y,  12);
    if (this.y < 50)
    {direction = 1;}
    if (this.y > 320 && direction === 1) 
    {score += 10;
    direction = 0;}
};

Bitmoji.prototype.hop = function() {//hop method
    this.img = getImage("creatures/Hopper-Jumping");
    this.y -= 5;
};

Bitmoji.prototype.fall = function() {//fall method
    this.img = getImage("creatures/Hopper-Happy");
    this.y += 5;
};


var mazeBlocks = [];//array of ships

Bitmoji.prototype.ranIntoBlocks = function(block) {//Hit by Ship Method, if Bitmoi is hit by a ship, points are deducted.
    if ((block.x >= this.x && block.x <= (this.x + 40)) &&
        (block.y >= this.y && block.y <= (this.y + 40)))
        {
        block.y = -400;
        this.ranIntoBlock++;
        score -=  10;
    }
};

var Maze = function(x, y) {//class called spaceShips
    this.x = x;
    this.y = y;
    this.direction = direction;
};
Maze.prototype.draw = function() {
    fill(random(0,255),random(0,255),random(0,255));
    rectMode(CENTER);
    rect(this.x, this.y, 50, 70);
    
};

var julissa = new Bitmoji(200, 317);//bitmpji displayed on the screen

for (var i = 0; i < numBlocks; i++) { //repeating the drawing of ship
    mazeBlocks.push(new Maze(11 + -i *  110 , random(20, 260)), 1);}//spaced sticks out 

var Game = function() {//User Interaction of Program
    currentScene = 2;
    background(0, 0, 0);
    fill(255, 255, 255);
    rectMode(CORNER);
    rect(0, height*0.90, width, height*0.10);
    rect(0, height*0.00, width, height*0.10);
    
    for (var i = 0; i < mazeBlocks.length; i++) { //For loop that draws ships, when the loop reaches an index of 49 the ships will double there speeds across the screens.
    mazeBlocks[i].draw();
    julissa.ranIntoBlocks(mazeBlocks[i]);
    mazeBlocks[i].x += 1;
    if (mazeBlocks[0].x > 48)
    {
        fill(255, 10, 96);
        textSize(20);
        text("P h a s e : 1", 10, 375);
    } 
    if (mazeBlocks[49].x > 0)
    {
        fill(255, 10, 96);
        textSize(20);
        mazeBlocks[i].x += 2;
        text("P h a s e : 2", 10, 375);
    }
}
    fill(255, 0, 0);
    textSize(18);
    text("Score: " + score , 8, 24);
    if(keyIsPressed && keyCode === 0) {// Keyboard  user interaction: if spacebar is pressed then bitmoji hops, else if not pressed then bitmoji falls.
        julissa.hop();
    } 
    else {
        julissa.fall();
    }
    julissa.draw();

};

draw = function() {//A draw funciton that is testing if the current scene is 0 then it will display the splash scene. If it is 1, it will display instructionsScene, and if it's 2, it will show the Game scene. 
    if (currentScene === 0 && stillPlaying === true)
        {
            splash();
        }
    else if (currentScene === 1 && stillPlaying === true)
    {
        instructionsScene();
    }
    else if (currentScene === 2 && stillPlaying === true)
    {
        Game();
        
    }
     if (mazeBlocks[119].x > 400)//Once all ships have passed across the yoo x -axis mark, the game is over. The user can then click "play again" to restart the game.
    {   
        noLoop();
        currentScene = 2;
        fill(255, 255, 255);
        textSize(60);
        textFont(createFont("Berlin Sans FB"),60);
        text("Game Over", 67,279);
        playAgainButton.draw();
    }      
};

